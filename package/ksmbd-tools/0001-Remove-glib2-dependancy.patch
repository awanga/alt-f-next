diff --git a/addshare/Makefile.am b/addshare/Makefile.am
index 30ee948..80a5a79 100644
--- a/addshare/Makefile.am
+++ b/addshare/Makefile.am
@@ -1,7 +1,7 @@
 AM_CFLAGS = -DSYSCONFDIR='"${sysconfdir}"' -DRUNSTATEDIR='"${runstatedir}"' \
             -I$(top_srcdir)/include $(GLIB_CFLAGS) $(LIBNL_CFLAGS) -fno-common
 LIBS = $(GLIB_LIBS)
-ksmbd_addshare_LDADD = $(top_builddir)/lib/libksmbdtools.a
+ksmbd_addshare_LDADD = $(top_builddir)/lib/libksmbdtools.a -lpthread
 
 sbin_PROGRAMS = ksmbd.addshare
 
diff --git a/addshare/addshare.c b/addshare/addshare.c
index 80aef55..e0b26e0 100644
--- a/addshare/addshare.c
+++ b/addshare/addshare.c
@@ -5,7 +5,6 @@
  *   linux-cifsd-devel@lists.sourceforge.net
  */
 
-#include <glib.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <unistd.h>
diff --git a/addshare/share_admin.c b/addshare/share_admin.c
index 7323861..e909dc6 100644
--- a/addshare/share_admin.c
+++ b/addshare/share_admin.c
@@ -5,7 +5,6 @@
  *   linux-cifsd-devel@lists.sourceforge.net
  */
 
-#include <glib.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <unistd.h>
diff --git a/adduser/Makefile.am b/adduser/Makefile.am
index 14d30d2..b67e014 100644
--- a/adduser/Makefile.am
+++ b/adduser/Makefile.am
@@ -1,7 +1,7 @@
 AM_CFLAGS = -DSYSCONFDIR='"${sysconfdir}"' -DRUNSTATEDIR='"${runstatedir}"' \
             -I$(top_srcdir)/include $(GLIB_CFLAGS) $(LIBNL_CFLAGS) -fno-common
 LIBS = $(GLIB_LIBS)
-ksmbd_adduser_LDADD = $(top_builddir)/lib/libksmbdtools.a
+ksmbd_adduser_LDADD = $(top_builddir)/lib/libksmbdtools.a -lpthread
 
 sbin_PROGRAMS = ksmbd.adduser
 
diff --git a/adduser/adduser.c b/adduser/adduser.c
index bf49475..5d3624e 100644
--- a/adduser/adduser.c
+++ b/adduser/adduser.c
@@ -5,7 +5,6 @@
  *   linux-cifsd-devel@lists.sourceforge.net
  */
 
-#include <glib.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <unistd.h>
diff --git a/adduser/user_admin.c b/adduser/user_admin.c
index a989009..5647a6f 100644
--- a/adduser/user_admin.c
+++ b/adduser/user_admin.c
@@ -5,7 +5,6 @@
  *   linux-cifsd-devel@lists.sourceforge.net
  */
 
-#include <glib.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <unistd.h>
diff --git a/configure.ac b/configure.ac
index c09770c..0173034 100644
--- a/configure.ac
+++ b/configure.ac
@@ -87,11 +87,6 @@ AS_IF([test "x$with_systemdsystemunitdir" != xno], [
 
 AC_SUBST([systemdsystemunitdir])
 
-PKG_CHECK_MODULES([GLIB], [glib-2.0 >= 2.40], [have_glib=yes], [have_glib=no])
-AS_IF([test "x$have_glib" != xyes], [
-	AC_MSG_ERROR([glib (libglib2.0-dev or glib2-devel) was not found.])
-])
-
 PKG_CHECK_MODULES([LIBNL], [libnl-3.0 >= 3.0 libnl-genl-3.0 >= 3.0], [have_libnl=yes], [have_libnl=no])
 AS_IF([test "x$have_libnl" != xyes], [
 	AC_MSG_ERROR([libnl (libnl-3-dev or libnl3-devel) and libnl-genl (libnl-genl-3-dev) were not found.])
diff --git a/include/config_parser.h b/include/config_parser.h
index 43212c8..9d4ed10 100644
--- a/include/config_parser.h
+++ b/include/config_parser.h
@@ -8,7 +8,7 @@
 #ifndef __KSMBD_CONFIG_H__
 #define __KSMBD_CONFIG_H__
 
-#include <glib.h>
+#include "ksmbdtools.h"
 
 #define GROUPS_CALLBACK_NONE	(0)
 #define GROUPS_CALLBACK_INIT	(1 << 0)
diff --git a/include/ksmbdtools.h b/include/ksmbdtools.h
index 3be953e..9ea784c 100644
--- a/include/ksmbdtools.h
+++ b/include/ksmbdtools.h
@@ -14,7 +14,6 @@
 
 #include <errno.h>
 #include <getopt.h>
-#include <glib.h>
 #include <poll.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -23,11 +22,380 @@
 #include <sys/wait.h>
 #include <time.h>
 #include <unistd.h>
+#include <pthread.h>
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+/*********/
+
+#include <limits.h>
+#include <stdint.h>
+#include <stdarg.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+
+#if     __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
+#define G_GNUC_PRINTF( format_idx, arg_idx )    \
+	__attribute__((__format__ (__printf__, format_idx, arg_idx)))
+#else   /* !__GNUC__ */
+#define G_GNUC_PRINTF( format_idx, arg_idx )
+#endif  /* !__GNUC__ */
+
+#define G_N_ELEMENTS(arr)   (sizeof (arr) / sizeof ((arr)[0]))
+
+#ifndef bool
+typedef enum { FALSE, TRUE } bool;
+#endif
+
+#define G_MAXSIZE	UINT_MAX
+
+#define gsize		size_t
+#define gchar		char
+#define gint		int
+#define guint		unsigned int
+#define gpointer	void*
+#define gboolean	bool
+#define gconstpointer	const void*
+
+#define GError		int
+#define GRand		int
+#define GArray		struct LIST
+#define GList		struct LIST
+#define GHashTable	struct LIST
+#define GRWLock		pthread_rwlock_t
+
+typedef void GHFunc(void *key, void* value, void* userData);
+
+typedef struct _GMappedFile {
+	gchar	*contents;
+	gsize	length;
+	gpointer free_func;
+	int	ref_count;
+} GMappedFile;
+
+/* Redefine the glib versions to stdlib versions */
+#define g_strdup		strdup
+#define g_strndup		strndup
+#define g_open			open
+#define g_print			printf
+#define g_printerr		pr_err
+#define g_close(fd,err)		((**err = close(fd)) == 0 ? TRUE : FALSE)
+#define g_strsplit_set		strsplit_set
+
+char **strsplit_set (const char *, const char *delimiters, int);
+
+static inline void g_strfreev (char **str_array)
+{
+	int i;
+
+	if (str_array) {
+		for (i = 0; str_array[i] != NULL; i++)
+			free(str_array[i]);
+
+		free (str_array);
+  	}
+}
+
+#define g_str_hash(s)		list_tokey(s)
+#define g_str_equal(a,b)	(strcmp(a, b) == 0)
+
+#define g_malloc		malloc
+#define g_malloc0(x)		calloc(1,x)
+#define g_realloc(x,y)		realloc(x,y)
+#define g_free			free
+#define g_try_malloc(x)		malloc(x)
+#define g_try_malloc0(x)	calloc(1,x)
+#define g_malloc_n(x,y)		malloc((x)*(y))
+#define g_malloc0_n(x,y)	calloc(1,(x)*(y))
+#define g_realloc_n(x,y,z)	realloc(x,(y)*(z))
+#define g_try_malloc_n(x,y)	malloc((x)*(y))
+#define g_try_malloc0_n(x,y)	calloc(1,(x)*(y))
+#define g_try_realloc_n(x,y,z)	realloc(x,(y)*(z))
+
+#define g_slice_new0(type)	((type *) calloc(1,sizeof(type)))
+#define g_slice_free(sz,ptr)	free(ptr)
+
+#define g_error_free(err)	free(err)
+
+/* Redefine glib lock to equivalent pthread calls */
+#define g_rw_lock_clear		pthread_rwlock_destroy
+#define g_rw_lock_reader_lock	pthread_rwlock_rdlock
+#define g_rw_lock_reader_unlock	pthread_rwlock_unlock
+#define g_rw_lock_writer_lock	pthread_rwlock_wrlock
+#define g_rw_lock_writer_unlock	pthread_rwlock_unlock
+
+static inline void g_rw_lock_init(pthread_rwlock_t *rw_lock)
+{
+	pthread_rwlock_init(rw_lock, NULL);
+}
+
+/* Redefint glib functons to helper functions */
+#define g_ascii_strup		ascii_strup
+#define g_ascii_strdown		ascii_strdown
+#define g_ascii_strcasecmp	strcasecmp
+#define g_ascii_strncasecmp	strncasecmp
+#define g_strdup_printf		strdup_printf
+
+char* strdup_printf (const gchar *format, ...);
+
+#define g_utf8_strlen		utf8_strlen
+#define g_utf8_find_next_char	utf8_find_next_char
+#define g_utf8_casefold		utf8_casefold
+#define g_utf8_normalize(ws,len,mode)	\
+				utf8_normalize(ws,len)
+
+long utf8_strlen (const char *p, size_t max);
+char *utf8_normalize (const char* str, size_t max_len);
+char* utf8_casefold(const char* input, size_t max_length);
+char *utf8_find_next_char (const char *p, const char *end);
+
+#define g_atomic_int_add	atomic_int_add
+#define g_atomic_int_inc	atomic_int_inc
+#define g_atomic_int_dec_and_test \
+				atomic_int_dec_and_test
+#define g_atomic_int_compare_and_exchange \
+				atomic_int_compare_and_exchange
+
+#define g_hash_table_foreach(hash,fn,data) \
+				list_foreach_hash(&hash,fn,data)
+#define g_hash_table_foreach_remove(hash,fn,data) \
+				list_foreach_hash_remove(&hash,fn,data)
+#define g_hash_table_remove(hash, key) \
+				list_remove(&hash, (uintptr_t)*key)
+#define g_hash_table_insert(hash,key,val) \
+				list_add(&hash,val,(uintptr_t)*key)
+#define g_hash_table_lookup(hash,key) \
+				list_get(&hash, (uintptr_t)key)
+#define g_hash_table_destroy(hash) \
+				list_clear(&hash)
+
+#define g_list_foreach(lst,fn,data) \
+				list_foreach(&lst,fn,data)
+#define g_list_free(lst)	list_clear(&lst)
+
+#define g_array_index(arr, type, num) \
+				list_get(&arr, num)
+#define g_array_set_clear_func(lst,fn) /* ignore */
+#define g_array_free(arr,val)	list_clear(&arr)
+
+char* ascii_strup(const char *str, size_t len);
+char *ascii_strdown(const char *str, size_t len);
+
+int atomic_int_add(volatile int *atomic, int val);
+bool atomic_int_dec_and_test(volatile int *atomic);
+void atomic_int_inc(volatile int *atomic);
+
+int atomic_int_compare_and_exchange(volatile int *atomic,
+				    int oldval, int newval);
+
+#define KEY_ID 0x0
+#define KEY_STRING 0x1
+struct LIST {
+	struct LIST *prev;
+	struct LIST *next;
+	int type;
+	uintptr_t id;
+	char *keystr;
+	void *item;
+};
+
+struct LIST *list_init(struct LIST **list);
+long long list_maxid(struct LIST **list);
+int list_add_str(struct LIST **list, void *item, char *str);
+int list_add(struct LIST **list, void *item, uintptr_t id);
+void list_append(struct LIST **list, void *item);
+int list_remove(struct LIST **list, uintptr_t id);
+int list_remove_dec(struct LIST **list, uintptr_t id);
+void *list_get(struct LIST **list, uintptr_t id);
+void list_clear(struct LIST **list);
+int list_foreach(struct LIST **list,
+                 void (*func)(void *item, void *user_data),
+                 void *user_data);
+int list_foreach_hash(struct LIST **list,
+		 void (*func)(void *item, void *id,
+		 void *user_data), void *user_data);
+int list_foreach_hash_remove(struct LIST **list,
+		 bool (*func)(void *item, void *id,
+		 void *user_data), void *user_data);
+
+static uintptr_t list_tokey(void *ptr)
+{
+	size_t p = (size_t)ptr;
+	return p;
+}
+
+static void *list_fromkey(uintptr_t key)
+{
+	size_t p = key;
+
+	return (void *)p;
+}
+
+/*****/
+#define g_rand_new(x)				(NULL)
+#define g_rand_int_range(rnd,lo,hi)		(((int)(rand()*(((double)(hi-lo))/RAND_MAX)))+lo)
+#define g_rand_free(x)
+
+#define G_FILE_TEST_EXISTS			F_OK
+#define g_file_test				access
+
+#define g_hash_table_new(a,b)			__g_hash_table_new()
+#define g_hash_table_new_full(a,b,c,d)		__g_hash_table_new()
+
+static inline struct LIST *__g_hash_table_new(void)
+{
+	struct LIST *new_hash;
+
+	list_init(&new_hash);
+	return new_hash;
+}
+
+#define g_list_insert(lst,data,pos)		__g_list_insert(&lst,data,pos)
+
+static inline struct LIST *__g_list_insert(struct LIST **list, void *data, int pos)
+{
+	list_add(list, data, pos);
+	return *list;
+}
+
+#define g_list_remove(lst,id)	__g_list_remove(&lst, (uintptr_t)id)
+
+static inline struct LIST *__g_list_remove(struct LIST **lst, uintptr_t id)
+{
+	list_remove(lst, id);
+	return *lst;
+}
+
+#define g_array_new(a,b,sz)			__g_hash_table_new()
+
+static inline struct LIST *__g_array_new(void)
+{
+	struct LIST *new_array;
+
+	list_init(&new_array);
+	return new_array;
+}
+
+#define g_array_append_val(arr, val)		__g_array_append_val(&arr,val)
+
+static inline struct LIST *__g_array_append_val(struct LIST **list, void *val)
+{
+	list_append(list, val);
+	return *list;
+}
+
+#define g_array_remove_index(arr, idx)		__g_array_remove_index(&arr,idx)
+
+static inline struct LIST *__g_array_remove_index(struct LIST **list, unsigned int val)
+{
+	list_remove_dec(list, val);
+	return *list;
+}
+
+
+static void g_mapped_file_destroy (GMappedFile *file)
+{
+	if (file->length)
+		munmap (file->contents, file->length);
+
+	g_slice_free (GMappedFile, file);
+}
+
+
+static inline GMappedFile *g_mapped_file_new_from_fd(int fd, bool writable,
+					    int **error)
+{
+	GMappedFile *file = NULL;
+	struct stat st;
+
+	file = g_slice_new0 (GMappedFile);
+	file->ref_count = 1;
+	file->free_func = g_mapped_file_destroy;
+
+	if (fstat (fd, &st) == -1)
+		goto out;
+
+	if (st.st_size == 0 && S_ISREG (st.st_mode))
+	{
+		file->length = 0;
+		file->contents = NULL;
+		return file;
+	}
+
+	file->contents = MAP_FAILED;
+
+	if (sizeof (st.st_size) > sizeof (gsize) && st.st_size > (off_t) G_MAXSIZE)
+	{
+		errno = EINVAL;
+	}
+	else
+	{
+		file->length = (gsize) st.st_size;
+		file->contents = (gchar *) mmap (NULL,  file->length,
+				       writable ? PROT_READ|PROT_WRITE : PROT_READ,
+				       MAP_PRIVATE, fd, 0);
+	}
+
+	if (file->contents == MAP_FAILED)
+		goto out;
+
+	return file;
+
+out:
+	g_slice_free (GMappedFile, file);
+
+	return NULL;
+}
+
+static inline char *g_mapped_file_get_contents (GMappedFile *file)
+{
+	if (file == NULL)
+		return NULL;
+
+	return file->contents;
+}
+
+static inline size_t g_mapped_file_get_length (GMappedFile *file)
+{
+	if (file == NULL)
+		return 0;
+
+	return file->length;
+}
+
+static inline void g_mapped_file_unref (GMappedFile *file)
+{
+	if (file == NULL)
+		return;
+
+	if (g_atomic_int_dec_and_test (&file->ref_count))
+		g_mapped_file_destroy (file);
+}
+
+
+/******/
+
+typedef enum {
+	step_A, step_B, step_C
+} base64_encodestep;
+
+typedef struct {
+	base64_encodestep step;
+	char result;
+	int stepcount;
+} base64_encodestate;
+
+typedef enum {
+	step_a, step_b, step_c, step_d
+} base64_decodestep;
+
+typedef struct {
+	base64_decodestep step;
+	char plainchar;
+} base64_decodestate;
+
 struct smbconf_global {
 	int			flags;
 	int			map_to_guest;
@@ -146,12 +514,12 @@ void pr_hex_dump(const void *mem, size_t sz);
 char *base64_encode(unsigned char *src, size_t srclen);
 unsigned char *base64_decode(char const *src, size_t *dstlen);
 
-gchar *ksmbd_gconvert(const gchar *str,
-		      gssize       str_len,
+char *ksmbd_gconvert(const char *str,
+		      size_t       str_len,
 		      int          to_codeset,
 		      int          from_codeset,
-		      gsize       *bytes_read,
-		      gsize       *bytes_written);
+		      size_t       *bytes_read,
+		      size_t       *bytes_written);
 
 enum charset_idx {
 	KSMBD_CHARSET_UTF8		= 0,
diff --git a/include/management/session.h b/include/management/session.h
index fe2422b..c7c70df 100644
--- a/include/management/session.h
+++ b/include/management/session.h
@@ -8,7 +8,7 @@
 #ifndef __MANAGEMENT_TCONNECTION_H__
 #define __MANAGEMENT_TCONNECTION_H__
 
-#include <glib.h>
+#include "ksmbdtools.h"
 
 struct ksmbd_user;
 
diff --git a/include/management/share.h b/include/management/share.h
index d6ed0a6..7bc3cb3 100644
--- a/include/management/share.h
+++ b/include/management/share.h
@@ -8,7 +8,7 @@
 #ifndef __MANAGEMENT_SHARE_H__
 #define __MANAGEMENT_SHARE_H__
 
-#include <glib.h>
+#include "ksmbdtools.h"
 
 
 enum share_users {
diff --git a/include/management/tree_conn.h b/include/management/tree_conn.h
index 43b7581..18f5bb4 100644
--- a/include/management/tree_conn.h
+++ b/include/management/tree_conn.h
@@ -8,7 +8,7 @@
 #ifndef __MANAGEMENT_TREE_CONN_H__
 #define __MANAGEMENT_TREE_CONN_H__
 
-#include <glib.h>
+#include "ksmbdtools.h"
 
 struct ksmbd_share;
 
diff --git a/include/management/user.h b/include/management/user.h
index 7482051..c1ec791 100644
--- a/include/management/user.h
+++ b/include/management/user.h
@@ -10,7 +10,7 @@
 
 #include <sys/types.h>
 #include <pwd.h>
-#include <glib.h>
+#include "ksmbdtools.h"
 
 struct ksmbd_user {
 	char		*name;
diff --git a/include/rpc.h b/include/rpc.h
index 0fa99d4..46cf793 100644
--- a/include/rpc.h
+++ b/include/rpc.h
@@ -9,7 +9,7 @@
 #define __KSMBD_RPC_H__
 
 #include <linux/types.h>
-#include <glib.h>
+#include "ksmbdtools.h"
 
 #define KSMBD_DCERPC_LITTLE_ENDIAN	(1 << 0)
 #define KSMBD_DCERPC_ALIGN2		(1 << 1)
diff --git a/include/smbacl.h b/include/smbacl.h
index b0fe131..5dd4f03 100644
--- a/include/smbacl.h
+++ b/include/smbacl.h
@@ -10,8 +10,8 @@
 #define __KSMBD_SMBACL_H__
 
 #include <linux/types.h>
-#include <glib.h>
 #include <rpc.h>
+#include "ksmbdtools.h"
 
 #define NUM_AUTHS (6)	/* number of authority fields */
 #define SID_MAX_SUB_AUTHORITIES (15) /* max number of sub authority fields */
diff --git a/lib/asn1.c b/lib/asn1.c
index 3dc19e0..3771827 100644
--- a/lib/asn1.c
+++ b/lib/asn1.c
@@ -15,7 +15,6 @@
 #include <limits.h>
 #include <string.h>
 #include <errno.h>
-#include <glib.h>
 
 #include "asn1.h"
 
diff --git a/lib/config_parser.c b/lib/config_parser.c
index 53b2e03..1077bd8 100644
--- a/lib/config_parser.c
+++ b/lib/config_parser.c
@@ -5,9 +5,7 @@
  *   linux-cifsd-devel@lists.sourceforge.net
  */
 
-#include <glib.h>
 #include <string.h>
-#include <glib/gstdio.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <unistd.h>
@@ -199,7 +197,7 @@ static int __mmap_parse_file(const char *fname, int (*callback)(char *data))
 
 	file = g_mapped_file_new_from_fd(fd, FALSE, &err);
 	if (err) {
-		pr_err("Can't map `%s' to memory: %s\n", fname, err->message);
+		pr_err("Can't map `%s' to memory: %d\n", fname, *err);
 		g_error_free(err);
 		ret = -EINVAL;
 		goto out;
@@ -249,7 +247,7 @@ out:
 	if (fd) {
 		g_close(fd, &err);
 		if (err) {
-			pr_err("Can't close `%s': %s\n", fname, err->message);
+			pr_err("Can't close `%s': %d\n", fname, *err);
 			g_error_free(err);
 		}
 	}
diff --git a/lib/ksmbdtools.c b/lib/ksmbdtools.c
index d8ff339..2646e10 100644
--- a/lib/ksmbdtools.c
+++ b/lib/ksmbdtools.c
@@ -6,17 +6,569 @@
  */
 
 #include <syslog.h>
+#include <iconv.h>
 
 #include <unistd.h>
 #include <sys/stat.h>
 #include <fcntl.h>
+#include <ctype.h>
+#include <wchar.h>
+#include <wctype.h>
+#include <locale.h>
 
 #include <stdio.h>
+#include <stdarg.h>
 #include <ksmbdtools.h>
 
 int log_level = PR_INFO;
 int ksmbd_health_status;
 
+/*
+ * special simple linked list implementation, just made for the need of ksmbd.
+ * not yet optimized
+ */
+
+struct LIST *list_init(struct LIST **list)
+{
+	*list = malloc(sizeof(struct LIST));
+	if (!*list)
+		return NULL;
+	(*list)->prev = NULL;
+	(*list)->next = NULL;
+	return *list;
+}
+
+long long list_maxid(struct LIST **list)
+{
+	long long id = -1;
+	struct LIST *head = *list;
+
+	while ((head = head->next)) {
+		if (((long long)head->id) >= id)
+			id = head->id;
+	}
+	return id;
+}
+
+int list_foreach(struct LIST **list,
+		 void (*func)(void *item, void *user_data),
+		 void *user_data)
+{
+	struct LIST *head = *list;
+
+	while ((head = head->next)) {
+		if (head->type == KEY_STRING)
+			func(head->item, user_data);
+		else
+			func(head->item, user_data);
+	}
+}
+
+int list_foreach_hash(struct LIST **list,
+		void (*func)(void *item, void *id,
+			      void *user_data),
+		void *user_data)
+{
+	struct LIST *last = *list, *head = *list;
+
+	while ((head = head->next)) {
+		func(head->item,
+		     (void *)
+		     ((head->type == KEY_STRING) ? list_tokey(head->keystr) : head->id),
+		     user_data);
+	}
+}
+
+int list_foreach_hash_remove(struct LIST **list,
+		bool (*func)(void *item, void *id,
+			      void *user_data),
+		void *user_data)
+{
+	struct LIST *last = *list, *head = *list;
+	bool res;
+
+	while ((head = head->next)) {
+		func(head->item,
+		     (void *)
+		     ((head->type == KEY_STRING) ? list_tokey(head->keystr) : head->id),
+		     user_data);
+
+		if (res) {
+			list_remove(list, (uintptr_t)user_data);
+			head = last;
+		} else
+			last = last->next;
+
+	}
+}
+
+struct LIST *head_get(struct LIST **list, uintptr_t id)
+{
+	struct LIST *head = *list;
+	struct LIST *last = NULL;
+
+	head = *list;
+	while ((head = head->next)) {
+		if (head == last) {
+			/* should not happen. if this triggers we have a bug */
+			pr_debug("fixup list\n");
+			head->next = NULL;
+			break;
+		}
+		last = head;
+		if (head->type == KEY_STRING) {
+			char *c = (char *)list_fromkey(id);
+
+			if (!strcmp(head->keystr, c))
+				return head;
+		} else {
+			if (head->id == id)
+				return head;
+		}
+	}
+	return NULL;
+}
+
+static int _list_add(struct LIST **list, void *item, uintptr_t id, char *str)
+{
+	int ret = 1;
+	struct LIST *new;
+
+	if (!*list)
+		list_init(list);
+	new = head_get(list, str ? list_tokey(str) : id);
+	if (new)
+		ret = 0;
+	if (!new)
+		new = malloc(sizeof(struct LIST));
+	if (!new)
+		return 0;
+
+	new->item = item;
+	if (ret) {
+		if (str) {
+			new->keystr = str;
+			new->type = KEY_STRING;
+		} else {
+			new->id = id;
+			new->type = KEY_ID;
+		}
+		new->next = NULL;
+		struct LIST *head = *list;
+		struct LIST *last = head;
+
+		while ((head = head->next))
+			last = head;
+
+		last->next = new;
+		new->prev = last;
+	}
+	return ret;
+}
+
+int list_add(struct LIST **list, void *item, uintptr_t id)
+{
+	return _list_add(list, item, id, NULL);
+}
+
+int list_add_str(struct LIST **list, void *item, char *str)
+{
+	return _list_add(list, item, 0, str);
+}
+
+void list_append(struct LIST **list, void *item)
+{
+	_list_add(list, item, list_maxid(list) + 1, NULL);
+}
+
+static int _list_remove(struct LIST **list, uintptr_t id, int dec)
+{
+	int ret = 0;
+	struct LIST *head = *list;
+	struct LIST *next = NULL;
+
+	while ((head = head->next)) {
+		if ((head->type == KEY_ID && head->id == id)
+		    || (head->type == KEY_STRING
+			&& !strcmp(head->keystr, list_fromkey(id)))) {
+			if (head->prev)
+				head->prev->next = head->next;
+
+			if (head->next)
+				next = head->next;
+			head->next->prev = head->prev;
+
+			free(head);
+			ret = 1;
+			goto out;
+		}
+	}
+out:
+	if (dec && !ret && next) {
+		/* reorder all following ids after removing slot */
+		while (next) {
+			next->id = next->prev->id + 1;
+			next = next->next;
+		}
+	}
+	return ret;
+}
+
+int list_remove_dec(struct LIST **list, uintptr_t id)
+{
+	return _list_remove(list, id, 1);
+}
+
+int list_remove(struct LIST **list, uintptr_t id)
+{
+	return _list_remove(list, id, 0);
+}
+
+void *list_get(struct LIST **list, uintptr_t id)
+{
+	struct LIST *head = head_get(list, id);
+
+	if (head)
+		return head->item;
+	return NULL;
+}
+
+void list_clear(struct LIST **list)
+{
+	struct LIST *head = *list;
+
+	if (head)
+		return;
+
+	while (head) {
+		struct LIST *h = head->next;
+
+		free(head);
+		head = h;
+	}
+	*list = NULL;
+}
+
+struct slist {
+	struct slist *next;
+	const char *data;
+};
+
+static inline struct slist *slist_prepend(struct slist *head,
+					  const char *data)
+{
+	struct slist *nhead;
+
+	if (head == NULL)
+	{
+		head = malloc(sizeof(struct slist));
+		head->next = NULL;
+		head->data = data;
+		return head;
+	}
+
+	nhead = malloc(sizeof(struct slist));
+	nhead->next = head;
+	nhead->data = data;
+
+	return nhead;
+}
+
+void slist_free(struct slist *head)
+{
+	struct slist *next;
+
+	while (head != NULL)
+	{
+		next = head->next;
+		free(head);
+		head = next;
+	}
+}
+
+
+char **strsplit_set (const char *string,
+		     const char *delimiters,
+		     int         max_tokens)
+{
+	bool delim_table[256];
+	struct slist *tokens, *list;
+	int n_tokens;
+	const char *s;
+	const char *current;
+	char *token;
+	char **result;
+
+	if (string == NULL || delimiters == NULL)
+		return NULL;
+
+	if (max_tokens < 1)
+		max_tokens = UINT_MAX;
+
+	if (*string == '\0')
+	{
+		result = (char **) malloc(sizeof(char *));
+		result[0] = NULL;
+		return result;
+	}
+
+	memset (delim_table, FALSE, sizeof (delim_table));
+	for (s = delimiters; *s != '\0'; ++s)
+		delim_table[*(unsigned char *)s] = TRUE;
+
+	tokens = NULL;
+	n_tokens = 0;
+	s = current = string;
+	while (*s != '\0')
+	{
+		if (delim_table[*(unsigned char *)s] && n_tokens + 1 < max_tokens)
+		{
+			token = strndup (current, s - current);
+			tokens = slist_prepend (tokens, token);
+			++n_tokens;
+
+			current = s + 1;
+		}
+
+		++s;
+	}
+
+	token = strndup (current, s - current);
+	tokens = slist_prepend (tokens, token);
+	++n_tokens;
+
+	result = (char **)malloc(sizeof(char *) * n_tokens + 1);
+
+	result[n_tokens] = NULL;
+
+	for (list = tokens; list != NULL; list = list->next)
+		result[--n_tokens] = list->data;
+
+	slist_free (tokens);
+	return result;
+}
+
+#define UTF8_COMPUTE(Char, Mask, Len)                    \
+	if (Char < 128)                         \
+	{                               \
+		Len = 1;                            \
+		Mask = 0x7f;                           \
+	}                               \
+	else if ((Char & 0xe0) == 0xc0)                     \
+	{                               \
+		Len = 2;                            \
+		Mask = 0x1f;                           \
+	}                               \
+	else if ((Char & 0xf0) == 0xe0)                     \
+	{                               \
+		Len = 3;                            \
+		Mask = 0x0f;                           \
+	}                               \
+	else if ((Char & 0xf8) == 0xf0)                     \
+	{                               \
+		Len = 4;                            \
+		Mask = 0x07;                           \
+	}                               \
+	else if ((Char & 0xfc) == 0xf8)                     \
+	{                               \
+ 		Len = 5;                            \
+ 		Mask = 0x03;                           \
+	}                               \
+	else if ((Char & 0xfe) == 0xfc)                     \
+	{                               \
+		Len = 6;                            \
+		Mask = 0x01;                           \
+	}                               \
+	else                                 \
+		Len = -1;
+
+#define UTF8_LENGTH(Char)              \
+	((Char) < 0x80 ? 1 :                 \
+	 ((Char) < 0x800 ? 2 :               \
+	  ((Char) < 0x10000 ? 3 :            \
+	   ((Char) < 0x200000 ? 4 :          \
+	    ((Char) < 0x4000000 ? 5 : 6)))))
+
+#define UTF8_GET(Result, Chars, Count, Mask, Len)              \
+	(Result) = (Chars)[0] & (Mask);                     \
+	for ((Count) = 1; (Count) < (Len); ++(Count))                \
+	{                               \
+		if (((Chars)[(Count)] & 0xc0) != 0x80)                \
+		{                             \
+			(Result) = -1;                       \
+			break;                         \
+		}                             \
+		(Result) <<= 6;                           \
+		(Result) |= ((Chars)[(Count)] & 0x3f);                \
+	}
+
+static uint32_t utf8_get_char (const gchar *p)
+{
+	int i, mask = 0, len;
+	uint32_t result;
+	unsigned char c = (unsigned char) *p;
+
+	UTF8_COMPUTE (c, mask, len);
+	if (len == -1)
+		return (uint32_t)-1;
+	UTF8_GET (result, p, i, mask, len);
+
+	return result;
+}
+
+#define utf8_next_char(p) (char *)((p) + utf8_skip[*(unsigned char *)(p)])
+
+static const char utf8_skip_data[256] = {
+  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+  3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,1,1
+};
+
+static const char * const utf8_skip = utf8_skip_data;
+
+char *utf8_find_next_char (const char *p,
+			   const char *end)
+{
+	if (end)
+	{
+		for (++p; p < end && (*p & 0xc0) == 0x80; ++p)
+			;
+		return (p >= end) ? NULL : (gchar *)p;
+	}
+	else
+	{
+		for (++p; (*p & 0xc0) == 0x80; ++p)
+			;
+		return (char *)p;
+	}
+}
+
+long utf8_strlen (const char *p, size_t max)
+{
+  long len = 0;
+  const char *start = p;
+
+  if (p == NULL || max == 0)
+	return 0;
+
+  if (max < 0)
+    {
+      while (*p)
+        {
+          p = utf8_next_char (p);
+          ++len;
+        }
+    }
+  else
+    {
+      if (max == 0 || !*p)
+        return 0;
+
+      p = utf8_next_char (p);
+
+      while (p - start < max && *p)
+        {
+          ++len;
+          p = utf8_next_char (p);
+        }
+
+      /* only do the last len increment if we got a complete
+       * char (don't count partial chars)
+       */
+      if (p - start <= max)
+        ++len;
+    }
+
+  return len;
+}
+
+// Function to perform case-folding on a UTF-8 string
+char* utf8_casefold(const char* input, size_t max_length)
+{
+    if (input == NULL || max_length == 0)
+        return NULL;
+
+    // Allocate memory for the output string
+    char* output = (char*)malloc((max_length + 1) * sizeof(char));
+    if (output == NULL)
+        return NULL;
+
+    // Set the locale to the user's default locale
+    setlocale(LC_ALL, "");
+
+    size_t i, j;
+    for (i = 0, j = 0; i < max_length && input[i] != '\0'; ++i, ++j) {
+        char current_char = input[i];
+
+        // Use towlower from the locale to perform case-folding
+        wint_t wide_char;
+        mbtowc(&wide_char, &current_char, 1);
+        wint_t folded_char = towlower(wide_char);
+
+        // Convert the folded wide character back to UTF-8
+        wchar_t folded_wchar = folded_char;
+        wctomb(&output[j], folded_wchar);
+
+        // Handle multi-byte characters
+        if (output[j] == '\0')
+            return NULL;
+    }
+
+    // Null-terminate the output string
+    output[j] = '\0';
+
+    return output;
+}
+
+char *utf8_normalize(const char *input, size_t max_length)
+{
+    // Set the locale to the user's default locale
+    setlocale(LC_ALL, "");
+
+    // Calculate the length of the input string, limiting it to max_length
+    size_t input_len = strnlen(input, max_length);
+
+    // Allocate memory for the normalized string
+    size_t output_size = input_len * 4;  // Maximum expansion for NFC normalization
+    char *output = (char *)malloc(output_size);
+    if (output == NULL)
+        return NULL;
+
+    // Set up input and output pointers
+    const char *input_ptr = input;
+    char *output_ptr = output;
+
+    // Convert the input string to NFC-normalized UTF-8
+    mbstate_t mbstate = {0};  // Initialize the conversion state
+    while (*input_ptr != '\0' && input_len > 0) {
+        wchar_t wc;
+        size_t mb_len = mbrtowc(&wc, input_ptr, MB_CUR_MAX, &mbstate);
+
+        if (mb_len == (size_t)-1 || mb_len == (size_t)-2)
+            return NULL;
+
+        input_ptr += mb_len;
+        input_len -= mb_len;
+
+        // Convert the wide character back to multibyte and append to the output
+        size_t converted_len = wcrtomb(output_ptr, wc, &mbstate);
+        if (converted_len == (size_t)-1)
+            return NULL;
+
+        output_ptr += converted_len;
+    }
+
+    *output_ptr = '\0';  // Null-terminate the output string
+
+    return output;
+}
+
+
 static const char *app_name = "unknown";
 static int log_open;
 
@@ -144,18 +696,217 @@ void pr_hex_dump(const void *mem, size_t sz)
 }
 #endif
 
+void base64_init_encodestate(base64_encodestate *state_in)
+{
+	state_in->step = step_A;
+	state_in->result = 0;
+	state_in->stepcount = 0;
+}
+
+char base64_encode_value(char value_in)
+{
+	static const char *encoding =
+	    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+
+	if (value_in > 63)
+		return '=';
+	return encoding[(int)value_in];
+}
+
+int base64_encode_block(const char *plaintext_in, int length_in, char *code_out,
+			base64_encodestate *state_in)
+{
+	const char *plainchar = plaintext_in;
+	const char *const plaintextend = plaintext_in + length_in;
+	char *codechar = code_out;
+	char result;
+	char fragment;
+
+	result = state_in->result;
+
+	switch (state_in->step) {
+		while (1) {
+		case step_A:
+			if (plainchar == plaintextend) {
+				state_in->result = result;
+				state_in->step = step_A;
+				return codechar - code_out;
+			}
+			fragment = *plainchar++;
+			result = (fragment & 0x0fc) >> 2;
+			*codechar++ = base64_encode_value(result);
+			result = (fragment & 0x003) << 4;
+		case step_B:
+			if (plainchar == plaintextend) {
+				state_in->result = result;
+				state_in->step = step_B;
+				return codechar - code_out;
+			}
+			fragment = *plainchar++;
+			result |= (fragment & 0x0f0) >> 4;
+			*codechar++ = base64_encode_value(result);
+			result = (fragment & 0x00f) << 2;
+		case step_C:
+			if (plainchar == plaintextend) {
+				state_in->result = result;
+				state_in->step = step_C;
+				return codechar - code_out;
+			}
+			fragment = *plainchar++;
+			result |= (fragment & 0x0c0) >> 6;
+			*codechar++ = base64_encode_value(result);
+			result = (fragment & 0x03f) >> 0;
+			*codechar++ = base64_encode_value(result);
+
+			++(state_in->stepcount);
+		}
+	}
+	/* control should not reach here */
+	return codechar - code_out;
+}
+
+int base64_encode_blockend(char *code_out, base64_encodestate *state_in)
+{
+	char *codechar = code_out;
+
+	switch (state_in->step) {
+	case step_B:
+		*codechar++ = base64_encode_value(state_in->result);
+		*codechar++ = '=';
+		*codechar++ = '=';
+		break;
+	case step_C:
+		*codechar++ = base64_encode_value(state_in->result);
+		*codechar++ = '=';
+		break;
+	case step_A:
+		break;
+	}
+
+	return codechar - code_out;
+}
+
 char *base64_encode(unsigned char *src, size_t srclen)
 {
-	return g_base64_encode(src, srclen);
+	char *out = malloc((srclen / 3 + 1) * 4 + 1);
+	base64_encodestate state;
+
+	base64_init_encodestate(&state);
+	int len = base64_encode_block(src, srclen, out, &state);
+
+	base64_encode_blockend(out + len, &state);
+	return out;
+}
+
+int base64_decode_value(char value_in)
+{
+	static const char decoding[] = {
+		62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1,
+		-1, -1, -2, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
+		    12, 13, 14, 15, 16, 17,
+		18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27,
+		    28, 29, 30, 31, 32, 33,
+		34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
+		    50, 51
+	};
+	static const char decoding_size = sizeof(decoding);
+
+	value_in -= 43;
+	if (value_in < 0 || value_in > decoding_size)
+		return -1;
+	return decoding[(int)value_in];
+}
+
+void base64_init_decodestate(base64_decodestate *state_in)
+{
+	state_in->step = step_a;
+	state_in->plainchar = 0;
+}
+
+int base64_decode_block(const char *code_in, int length_in, char *plaintext_out,
+			const int outlen, base64_decodestate *state_in)
+{
+	const char *codechar = code_in;
+	char *plainchar = plaintext_out;
+	char fragment;
+	int count = 0;
+
+	*plainchar = state_in->plainchar;
+
+	switch (state_in->step) {
+		while (1) {
+		case step_a:
+			do {
+				if (codechar == code_in + length_in) {
+					state_in->step = step_a;
+					state_in->plainchar = *plainchar;
+					return plainchar - plaintext_out;
+				}
+				fragment =
+				    (char)base64_decode_value(*codechar++);
+			} while (fragment < 0);
+			if (count > outlen)
+				return plainchar - plaintext_out;
+			*plainchar = (fragment & 0x03f) << 2;
+		case step_b:
+			do {
+				if (codechar == code_in + length_in) {
+					state_in->step = step_b;
+					state_in->plainchar = *plainchar;
+					return plainchar - plaintext_out;
+				}
+				fragment =
+				    (char)base64_decode_value(*codechar++);
+			} while (fragment < 0);
+			count += 1;
+			if (count > outlen)
+				return plainchar - plaintext_out;
+			*plainchar++ |= (fragment & 0x030) >> 4;
+			*plainchar = (fragment & 0x00f) << 4;
+		case step_c:
+			do {
+				if (codechar == code_in + length_in) {
+					state_in->step = step_c;
+					state_in->plainchar = *plainchar;
+					return plainchar - plaintext_out;
+				}
+				fragment =
+				    (char)base64_decode_value(*codechar++);
+			} while (fragment < 0);
+			count += 1;
+			if (count > outlen)
+				return plainchar - plaintext_out;
+			*plainchar++ |= (fragment & 0x03c) >> 2;
+			*plainchar = (fragment & 0x003) << 6;
+		case step_d:
+			do {
+				if (codechar == code_in + length_in) {
+					state_in->step = step_d;
+					state_in->plainchar = *plainchar;
+					return plainchar - plaintext_out;
+				}
+				fragment =
+				    (char)base64_decode_value(*codechar++);
+			} while (fragment < 0);
+			count++;
+			if (count > outlen)
+				return plainchar - plaintext_out;
+			*plainchar++ |= (fragment & 0x03f);
+		}
+	}
+	/* control should not reach here */
+	return plainchar - plaintext_out;
 }
 
 unsigned char *base64_decode(char const *src, size_t *dstlen)
 {
-	unsigned char *ret = g_base64_decode(src, dstlen);
+	base64_decodestate state;
 
-	if (ret)
-		ret[*dstlen] = 0x00;
-	return ret;
+	base64_init_decodestate(&state);
+	int len = ((strlen(src) / 4) * 3) + 1;
+	char *out = malloc(len);
+	*dstlen = base64_decode_block(src, strlen(src), out, len, &state);
+	return out;
 }
 
 static int codeset_has_altname(int codeset)
@@ -166,18 +917,18 @@ static int codeset_has_altname(int codeset)
 	return 0;
 }
 
-gchar *ksmbd_gconvert(const gchar *str,
-		      gssize       str_len,
+char *ksmbd_gconvert( const char *str,
+		      size_t       str_len,
 		      int          to_codeset,
 		      int          from_codeset,
-		      gsize       *bytes_read,
-		      gsize       *bytes_written)
+		      size_t       *bytes_read,
+		      size_t       *bytes_written)
 {
-	gchar *converted;
-	GError *err;
+	char *converted, *buf;
+	int err;
 
 retry:
-	err = NULL;
+	err = 0;
 	if (from_codeset >= KSMBD_CHARSET_MAX) {
 		pr_err("Unknown source codeset: %d\n", from_codeset);
 		return NULL;
@@ -188,14 +939,19 @@ retry:
 		return NULL;
 	}
 
-	converted = g_convert(str,
-			      str_len,
-			      ksmbd_conv_charsets[to_codeset],
-			      ksmbd_conv_charsets[from_codeset],
-			      bytes_read,
-			      bytes_written,
-			      &err);
-	if (err) {
+	buf = converted = malloc((str_len * 2) + 1);
+	memset(converted, 0, (str_len * 2) + 1);
+	iconv_t conv = iconv_open(ksmbd_conv_charsets[to_codeset],
+				  ksmbd_conv_charsets[from_codeset]);
+	*bytes_read = str_len;
+	*bytes_written = str_len * 2;
+	err = iconv(conv, (char **)&str, bytes_read, &converted, bytes_written);
+	*bytes_read = 0;
+	err = iconv(conv, NULL, bytes_read, &converted, bytes_written);
+	iconv_close(conv);
+	*bytes_written = (str_len * 2) - *bytes_written;
+	*bytes_read = str_len - *bytes_read;
+	if (err < 0) {
 		int has_altname = 0;
 
 		if (codeset_has_altname(to_codeset)) {
@@ -208,9 +964,6 @@ retry:
 			has_altname = 1;
 		}
 
-		pr_info("%s\n", err->message);
-		g_error_free(err);
-
 		if (has_altname) {
 			pr_info("Will try `%s' and `%s'\n",
 				ksmbd_conv_charsets[to_codeset],
@@ -218,12 +971,107 @@ retry:
 			goto retry;
 		}
 
-		pr_err("Can't convert string: %s\n", err->message);
-		g_error_free(err);
 		return NULL;
 	}
 
-	return converted;
+	return buf;
+}
+
+static pthread_mutex_t atomic_lock = PTHREAD_MUTEX_INITIALIZER;
+
+int atomic_int_add(volatile int *atomic, int val)
+{
+	int oldval;
+
+	pthread_mutex_lock(&atomic_lock);
+	oldval = *atomic;
+	*atomic = oldval + val;
+	pthread_mutex_unlock(&atomic_lock);
+	return oldval;
+}
+
+void atomic_int_inc(volatile int *atomic)
+{
+	pthread_mutex_lock(&atomic_lock);
+	(*atomic)++;
+	pthread_mutex_unlock(&atomic_lock);
+}
+
+bool atomic_int_dec_and_test(volatile int *atomic)
+{
+	bool res;
+
+	pthread_mutex_lock(&atomic_lock);
+	(*atomic)--;
+	res = (atomic == 0);
+	pthread_mutex_unlock(&atomic_lock);
+
+	return res;
+}
+
+int atomic_int_compare_and_exchange(volatile int *atomic, int oldval,
+				    int newval)
+{
+	int success;
+
+	pthread_mutex_lock(&atomic_lock);
+	success = (*atomic == oldval);
+	if (success)
+		*atomic = newval;
+
+	pthread_mutex_unlock(&atomic_lock);
+
+	return success;
+}
+
+char* strdup_vprintf (const char *format, va_list args)
+{
+  char *string = NULL;
+  vasprintf (&string, format, args);
+  return string;
+}
+
+char* strdup_printf (const char *format, ...)
+{
+	char *buffer;
+	va_list args;
+	va_start (args, format);
+	buffer = strdup_vprintf (format, args);
+	va_end (args);
+	return buffer;
+}
+
+char* ascii_strup(const char *str, size_t len)
+{
+	char *result, *s;
+
+	if (str == NULL)
+		return NULL;
+
+	if (len < 0)
+		len = (size_t) strlen (str);
+
+	result = strndup (str, (size_t) len);
+	for (s = result; *s; s++)
+		*s = toupper (*s);
+
+	return result;
+}
+
+char *ascii_strdown(const char *str, size_t len)
+{
+	char *result, *s;
+
+	if (!str)
+		return NULL;
+
+	if (len < 0)
+		len = strlen(str);
+
+	result = strndup(str, len);
+	for (s = result; *s; s++)
+		*s = tolower(*s);
+	return result;
 }
 
 int send_signal_to_ksmbd_mountd(int signo)
diff --git a/lib/management/session.c b/lib/management/session.c
index 0eca8fb..dc58dfa 100644
--- a/lib/management/session.c
+++ b/lib/management/session.c
@@ -7,7 +7,6 @@
 
 #include <stdlib.h>
 #include <string.h>
-#include <glib.h>
 
 #include "linux/ksmbd_server.h"
 #include "management/session.h"
@@ -187,9 +186,8 @@ static gint lookup_tree_conn(gconstpointer data, gconstpointer user_data)
 int sm_handle_tree_disconnect(unsigned long long sess_id,
 			      unsigned long long tree_conn_id)
 {
-	struct ksmbd_tree_conn dummy;
+	struct ksmbd_tree_conn *tree_conn;
 	struct ksmbd_session *sess;
-	GList *tc_list;
 
 	sess = sm_lookup_session(sess_id);
 	if (!sess)
@@ -197,14 +195,8 @@ int sm_handle_tree_disconnect(unsigned long long sess_id,
 
 	g_atomic_int_inc(&global_conf.sessions_cap);
 	g_rw_lock_writer_lock(&sess->update_lock);
-	dummy.id = tree_conn_id;
-	tc_list = g_list_find_custom(sess->tree_conns,
-				     &dummy,
-				     lookup_tree_conn);
-	if (tc_list) {
-		struct ksmbd_tree_conn *tree_conn;
-
-		tree_conn = (struct ksmbd_tree_conn *)tc_list->data;
+	tree_conn = list_get(&sess->tree_conns, tree_conn_id);
+	if (tree_conn) {
 		sess->tree_conns = g_list_remove(sess->tree_conns, tree_conn);
 		sess->ref_counter--;
 		tcm_tree_conn_free(tree_conn);
diff --git a/lib/management/share.c b/lib/management/share.c
index f045b42..921b202 100644
--- a/lib/management/share.c
+++ b/lib/management/share.c
@@ -7,7 +7,6 @@
 
 #include <stdlib.h>
 #include <string.h>
-#include <glib.h>
 #include <sys/types.h>
 #include <pwd.h>
 #include <grp.h>
diff --git a/lib/management/tree_conn.c b/lib/management/tree_conn.c
index a120969..442b562 100644
--- a/lib/management/tree_conn.c
+++ b/lib/management/tree_conn.c
@@ -7,7 +7,6 @@
 
 #include <stdlib.h>
 #include <string.h>
-#include <glib.h>
 
 #include "linux/ksmbd_server.h"
 #include "management/tree_conn.h"
diff --git a/lib/management/user.c b/lib/management/user.c
index 8f481c8..13cf08e 100644
--- a/lib/management/user.c
+++ b/lib/management/user.c
@@ -7,7 +7,6 @@
 
 #include <stdlib.h>
 #include <string.h>
-#include <glib.h>
 
 #include "linux/ksmbd_server.h"
 #include "management/user.h"
diff --git a/mountd/ipc.c b/mountd/ipc.c
index 8ee5a32..a3f8f27 100644
--- a/mountd/ipc.c
+++ b/mountd/ipc.c
@@ -6,7 +6,6 @@
  */
 
 #include <memory.h>
-#include <glib.h>
 #include <errno.h>
 #include <netlink/netlink.h>
 #include <netlink/msg.h>
diff --git a/mountd/rpc.c b/mountd/rpc.c
index ea85b0f..2cf24e3 100644
--- a/mountd/rpc.c
+++ b/mountd/rpc.c
@@ -7,7 +7,6 @@
 
 #include <memory.h>
 #include <endian.h>
-#include <glib.h>
 #include <errno.h>
 #include <linux/ksmbd_server.h>
 
diff --git a/mountd/rpc_lsarpc.c b/mountd/rpc_lsarpc.c
index 184883d..a64e0a8 100644
--- a/mountd/rpc_lsarpc.c
+++ b/mountd/rpc_lsarpc.c
@@ -7,7 +7,6 @@
 
 #include <memory.h>
 #include <endian.h>
-#include <glib.h>
 #include <pwd.h>
 #include <errno.h>
 #include <linux/ksmbd_server.h>
diff --git a/mountd/rpc_samr.c b/mountd/rpc_samr.c
index f4afadc..4b06095 100644
--- a/mountd/rpc_samr.c
+++ b/mountd/rpc_samr.c
@@ -7,7 +7,6 @@
 
 #include <memory.h>
 #include <endian.h>
-#include <glib.h>
 #include <errno.h>
 #include <linux/ksmbd_server.h>
 
diff --git a/mountd/rpc_srvsvc.c b/mountd/rpc_srvsvc.c
index 46c01d9..6817928 100644
--- a/mountd/rpc_srvsvc.c
+++ b/mountd/rpc_srvsvc.c
@@ -7,7 +7,6 @@
 
 #include <memory.h>
 #include <endian.h>
-#include <glib.h>
 #include <errno.h>
 #include <linux/ksmbd_server.h>
 
diff --git a/mountd/rpc_wkssvc.c b/mountd/rpc_wkssvc.c
index 489551c..7a71e3e 100644
--- a/mountd/rpc_wkssvc.c
+++ b/mountd/rpc_wkssvc.c
@@ -7,7 +7,6 @@
 
 #include <memory.h>
 #include <endian.h>
-#include <glib.h>
 #include <errno.h>
 #include <linux/ksmbd_server.h>
 
diff --git a/mountd/smbacl.c b/mountd/smbacl.c
index ac3e0f5..6883d70 100644
--- a/mountd/smbacl.c
+++ b/mountd/smbacl.c
@@ -8,7 +8,6 @@
 
 #include <smbacl.h>
 #include <ksmbdtools.h>
-#include <glib.h>
 
 static const struct smb_sid sid_domain = {1, 1, {0, 0, 0, 0, 0, 5},
 	{21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };
diff --git a/mountd/worker.c b/mountd/worker.c
index be8650b..4edb593 100644
--- a/mountd/worker.c
+++ b/mountd/worker.c
@@ -5,7 +5,8 @@
  *   linux-cifsd-devel@lists.sourceforge.net
  */
 #include <memory.h>
-#include <glib.h>
+#include <pthread.h>
+#include <semaphore.h>
 #include <errno.h>
 #include <linux/ksmbd_server.h>
 
@@ -20,7 +21,7 @@
 #include <management/spnego.h>
 
 #define MAX_WORKER_THREADS	4
-static GThreadPool *pool;
+static sem_t semaphore;
 
 #define VALID_IPC_MSG(m, t)					\
 	({							\
@@ -263,7 +264,7 @@ out:
 	return 0;
 }
 
-static void worker_pool_fn(gpointer event, gpointer user_data)
+static void *worker_pool_fn(void *event)
 {
 	struct ksmbd_ipc_msg *msg = (struct ksmbd_ipc_msg *)event;
 
@@ -306,38 +307,34 @@ static void worker_pool_fn(gpointer event, gpointer user_data)
 	}
 
 	ipc_msg_free(msg);
+	sem_post(&semaphore);
+	return NULL;
 }
 
 int wp_ipc_msg_push(struct ksmbd_ipc_msg *msg)
 {
-	return g_thread_pool_push(pool, msg, NULL);
+	pthread_attr_t attr;
+	pthread_t thread;
+
+	sem_wait(&semaphore);
+	pthread_attr_init(&attr);
+	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+	if (pthread_create(&thread, &attr, worker_pool_fn, msg) != 0) {
+		pthread_attr_destroy(&attr);
+		sem_post(&semaphore);
+		pr_err("error while creating worker thread\n");
+		return -1;
+	}
+	pthread_attr_destroy(&attr);
+	return 0;
 }
 
 void wp_destroy(void)
 {
-	if (pool)
-		g_thread_pool_free(pool, 1, 1);
+	sem_destroy(&semaphore);
 }
 
 int wp_init(void)
 {
-	GError *err;
-
-	pool = g_thread_pool_new(worker_pool_fn,
-				 NULL,
-				 MAX_WORKER_THREADS,
-				 0,
-				 &err);
-	if (!pool) {
-		if (err) {
-			pr_err("Can't create pool: %s\n", err->message);
-			g_error_free(err);
-		}
-		goto out_error;
-	}
-
-	return 0;
-out_error:
-	wp_destroy();
-	return -ENOMEM;
+	return sem_init(&semaphore, 0, MAX_WORKER_THREADS);
 }
